#!/usr/bin/perl

# dictdconfig -- generate dictd configuration database section
# Copyright (C) 1999-2000 Kirk Hilliard <kirk@debian.org>
#
# This is free software, published under version 2 or (at your option)
# any later version of the GNU General Public License.  You should
# have received a copy of the GNU General Public License with your
# Debian GNU/Linux system as /usr/share/common-licenses/GPL.

# 4/20/03 - version updated to 1.2.  Support for index_suffix and 
# index_word files added.  (Additional dictionaries were included in 
# my @db_order and support for dictdconfig.alias and the database_exit 
# directive was added earlier, without changing the version nmber.)

my @db_order = qw( web1913 gcide wn foldoc jargon vera devil elements easton hitchcock gazetteer );
my $db_dir      = "/usr/share/dictd";
push @db_order, "$db_dir/";
my %token;
$token{'database_exit'} = "database_exit\n";
my $dblist_file = "/var/lib/dictd/db.list";
my $prog_dir    = "/usr/sbin";
my $prog_name   = "dictdconfig";
my $conf_file   = "/etc/dictd/dictd.conf";
my $order_file  = "/etc/dictd/dictd.order";
my $alias_script = "/etc/dictd/dictdconfig.alias";
my %db_entered;
my ( $opt_write, $opt_list,  $opt_order, $opt_help, $opt_version);
my %opt_matrix = ( '-w' => \$opt_write,   '--write'   => \$opt_write,
                   '-l' => \$opt_list,    '--list'    => \$opt_list,
                   '-o' => \$opt_order,   '--order'   => \$opt_order,
                   '-h' => \$opt_help,    '--help'    => \$opt_help,
                   '-v' => \$opt_version, '--version' => \$opt_version );
my $help = <<EOT;
Usage: $prog_name [OPTIONS]
Generate dictd configuration database section for available dictionary
databases found in $db_dir/.

  -w, --write    write database section to $dblist_file
  -l, --list     list database section to standard out
  -o, --order    display dictionary database order information
  -h, --help     display this help and exit
  -v, --version  display version information and exit
EOT
my $version = "$prog_name 1.1\n";
my $output = <<EOT;
# Automatically generated file -- do not edit.
#
# This file was automatically generated by $prog_name.  Any changes
# made directly to this file will be lost when $prog_name is run upon
# installation, removal, or upgrade of a dictionary database package.
#
# This file provides a complete database section which may be
# included from the dictd configuration file $conf_file
# with an ``include $dblist_file'' line.  The order and
# presence of the dictionary database entries here may be modified
# via the optional $prog_name order override file $order_file.
# See $prog_name(8) for details.
#
# Older dictionary database packages did not automatically invoke
# $prog_dir/$prog_name upon installation and removal, so you may
# need to do so manually (after which, you should restart dictd).

EOT
my $order_file_found_comment = <<EOT;
# Optional order override file $order_file found.
# Ignoring default order.

EOT
my $order_file_not_found_comment = <<EOT;
# Optional order override file $order_file not found.
# Using default order.

EOT
my $none_found = <<EOT;
# No dictionary databases were found.
# This dummy entry allows dictd to start.

EOT
my $order_header = <<EOT;
Dictionary Database Order Summary  [See also $prog_name(8).]

Dictionary database entries will be generated only for those databases
found via basename and directory entries in the default order (or the
order override file, if present), and they will be generated in the
order in which these entries appear.  No more than one dictionary
database entry of any given name will be generated.

  Entries without a leading / are relative to $db_dir/.
  Entries without a trailing / are basenames.
    A dictionary database entry is generated if <basename>.index
    and <basename>.dict.dz or <basename>.dict are present.
  Entries with a trailing / are directories.
    A dictionary database entry is generated for each <name> where
    <directory>/<name>.index and <directory>/<name>.dict.dz or
    <directory>/<name>.dict are present.

Default Order:
EOT
my $order_file_found = <<EOT;
Optional order override file $order_file found.
Ignoring default order.

New Order:
EOT
my $order_file_not_found = <<EOT;
Optional order override file $order_file not found.
Using default order.

EOT

ParseCommandLine(@ARGV);
print $version if $opt_version;
print $help    if $opt_help;
exit if $opt_help || $opt_version;
if ( ! $opt_write && ! $opt_list && ! $opt_order ) {
    print "No action taken.\n";
    exit;
}
if ( $opt_order) {
    print $order_header;
    for (@db_order) { print "  $_\n"; }
    print "\n";
}

if ( -f $order_file ) {
    $output .= $order_file_found_comment;
    if ( $opt_order ) { print $order_file_found }
    open ORDER, "$order_file"
        or die "Can't open existing file `$order_file' for read: $!\n";
    undef @db_order;
    while (<ORDER>) {
        chomp;
        s/#.*//;
        push @db_order, split;
    }
    if ( $opt_order ) {
        for (@db_order) { print "  $_\n"; }
        print "\n";
    }
} else {
    $output .= $order_file_not_found_comment;
    if ( $opt_order) { print $order_file_not_found }
}

for (@db_order) {
    if ( $token{$_} ) { $output .= $token{$_} }
    elsif ( m#/$# ) { CheckDirectory( $_ ) }
    else { CheckDatabase( $_ ) }
}

if ( ! keys %db_entered ) {
    $output .= $none_found;
    AddEntry( "dummy", "/dev/null", "/dev/null" );
}

if ( $opt_list ) { print $output }

if ( $opt_write ) {
    open  DBLIST, ">$dblist_file"
        or die "Can't write to file $dblist_file: $!\n";
    print DBLIST $output;
    close DBLIST;
}

exit 0;

sub AddEntry {
    my ( $name, $datafile, $indexfile, $suffixfile, $wordfile ) = @_;
    $output .= "database $name {\n" .
               "  data  $datafile\n" .
               "  index $indexfile\n" .
               ( $suffixfile ? "  index_suffix $suffixfile\n" : "" ) .
               ( $wordfile ? "  index_word $wordfile\n" : "" ) .
               "}\n";
    ++$db_entered{ $name };
}

sub AliasName {
    my ( $name ) = @_;
    if ( -x $alias_script ) { $name = `echo $name | $alias_script` }
    return $name;
}

sub CheckDatabase {
    my ( $base_name ) = @_;
    my $name;
    my $datafile;
    my $indexfile;
    my $suffixfile;
    my $wordfile;
    if ( $base_name =~ m#.*/(.*)# ) { $name = $1 }
    else { $name = $base_name }
    $name = AliasName( $name );
    $base_name = "$db_dir/$base_name" unless $base_name =~ m#^/#;
    $datafile = "$base_name.dict.dz";
    $datafile =~ s/\.dz$// unless -f $datafile;
    $indexfile = "$base_name.index";
    $suffixfile = "$base_name.suffix";
    $wordfile = "$base_name.word";
    if ( ! $db_entered{ $name } && -f $datafile && -f $indexfile ) {
        undef $suffixfile unless -f $suffixfile;
        undef $wordfile unless -f $wordfile;
        AddEntry( $name, $datafile, $indexfile, $suffixfile, $wordfile );
    }
}

sub CheckDirectory {
    my ( $dir ) = @_;
    $dir = "$db_dir/$dir" unless $dir =~ m#^/#;
    opendir DIR, $dir;
    for (readdir DIR) {
        if ( /(^.*)\.index$/ ) { CheckDatabase( "$dir$1" ) }
    }
    closedir DIR;
}

sub ParseCommandLine {
    my $ref;
    for (@_) {
        if ( $ref = $opt_matrix{$_} ) { ++$$ref; }
        elsif ( /^-([^-].*)/ ) {
            for ( split //, $1 ) {
                if ( $ref = $opt_matrix{"-$_"} ) { ++$$ref; }
                else { die "$prog_name: unrecognized option `-$_'.\n" .
                           "Try `$0 --help' for more information.\n"; }
            }
        }
        else { die "$prog_name: unrecognized option `$_'.\n" .
                   "Try `$0 --help' for more information.\n"; }
    }
}
